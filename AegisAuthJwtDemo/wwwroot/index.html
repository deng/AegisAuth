<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JWT WebAuthn Demo</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background: #f5f5f5;
        }

        .container {
            max-width: 800px;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        .section {
            margin-bottom: 30px;
            border: 1px solid #ddd;
            padding: 20px;
            border-radius: 5px;
        }

        .section h2 {
            margin-top: 0;
            color: #333;
        }

        button {
            padding: 10px 20px;
            margin: 5px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        button:hover {
            background: #0056b3;
        }

        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        input,
        textarea {
            display: block;
            margin: 10px 0;
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }

        .result {
            margin-top: 10px;
            padding: 10px;
            border-radius: 4px;
        }

        .success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .info {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }

        .hidden {
            display: none;
        }

        .auth-section {
            background: #e7f3ff;
            padding: 15px;
            margin: 20px 0;
            border-radius: 5px;
            border-left: 4px solid #007bff;
        }

        .token-info {
            background: #f8f9fa;
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
            font-family: monospace;
            font-size: 12px;
            word-break: break-all;
        }
    </style>
</head>

<body>
    <div class="container">
        <h1>JWT WebAuthn Demo</h1>

        <div class="auth-section">
            <h3>Authentication Status</h3>
            <div id="authStatus" class="info">Not authenticated</div>
            <div id="tokenInfo" class="token-info hidden"></div>
            <button id="logoutBtn" onclick="logout()" class="hidden">Logout</button>
        </div>

        <div class="section">
            <h2>1. Register User</h2>
            <input type="text" id="registerUsername" placeholder="Username">
            <input type="password" id="registerPassword" placeholder="Password">
            <input type="password" id="registerConfirmPassword" placeholder="Confirm Password">
            <button onclick="registerUser()">Register User</button>
            <div id="registerResult" class="result hidden"></div>
        </div>

        <div class="section" id="loginSection">
            <h2>2. Login with Username/Password</h2>
            <input type="text" id="loginUsername" placeholder="Username">
            <input type="password" id="loginPassword" placeholder="Password">
            <button onclick="loginUser()">Login</button>
            <div id="loginResult" class="result hidden"></div>
        </div>

        <div class="section" id="enableTwoFactorSection" class="hidden">
            <h2>2.5. Enable Two-Factor Authentication</h2>
            <p style="color: #666; font-size: 14px;">For enhanced security, we recommend enabling two-factor
                authentication. You must first register a passkey before enabling 2FA.</p>
            <div id="enableTwoFactorSteps">
                <div id="passkeyRequiredStep" class="hidden">
                    <p style="color: #d9534f;">⚠️ You must register a passkey first before enabling two-factor
                        authentication.</p>
                    <p>Please go to step 3 below to register your passkey, then return here to enable 2FA.</p>
                </div>
                <div id="enableTwoFactorReady" class="hidden">
                    <p style="color: #5cb85c;">✅ You have registered a passkey. You can now enable two-factor
                        authentication.</p>
                    <button onclick="enableTwoFactor()">Enable Two-Factor Authentication</button>
                </div>
            </div>
            <div id="enableTwoFactorResult" class="result hidden"></div>
        </div>

        <div class="section" id="twoFactorSection" class="hidden">
            <h2>2.5. Two-Factor Authentication</h2>
            <p style="color: #666; font-size: 14px;">Complete two-factor authentication to finish logging in.</p>

            <div id="twoFactorPasskey" class="hidden">
                <p>Use your passkey to complete authentication:</p>
                <button onclick="verifyTwoFactorWithPasskey()">Authenticate with Passkey</button>
            </div>

            <div id="twoFactorCode" class="hidden">
                <p>Enter your verification code:</p>
                <input type="text" id="twoFactorCodeInput" placeholder="Enter verification code">
                <button onclick="verifyTwoFactorWithCode()">Verify Code</button>
            </div>

            <button onclick="cancelTwoFactor()" style="margin-top: 10px; background: #6c757d;">Cancel</button>
            <div id="twoFactorResult" class="result hidden"></div>
        </div>

        <div class="section" id="passkeySection" class="hidden">
            <h2>3. Register Passkey (2FA)</h2>
            <p style="color: #666; font-size: 14px;">Register a passkey as a second factor for authentication.</p>
            <button onclick="registerPasskey()">Register Passkey</button>
            <div id="passkeyRegisterResult" class="result hidden"></div>
        </div>

        <div class="section" id="signSection" class="hidden">
            <h2>4. Sign Data with Stored Private Key</h2>
            <p style="color: #666; font-size: 14px;">Sign data using the private key stored securely with WebAuthn PRF
                extension.</p>

            <label>Data to Sign:</label>
            <textarea id="dataToSign" rows="3"
                placeholder="Enter data to sign">This is data to be signed with the stored private key.</textarea>

            <button onclick="signData()">Sign Data</button>
            <div id="signResult" class="result hidden"></div>
        </div>
    </div>

    <script>
        const baseUrl = 'http://localhost:5187';
        let currentToken = null;
        let prfKey = null;

        // Initialize auth status on page load
        document.addEventListener('DOMContentLoaded', function () {
            const token = localStorage.getItem('jwt_token');
            if (token) {
                currentToken = token;
                updateAuthStatus(true);
                showAuthenticatedSections();
            }
        });

        function updateAuthStatus(isAuthenticated) {
            const authStatus = document.getElementById('authStatus');
            const tokenInfo = document.getElementById('tokenInfo');
            const logoutBtn = document.getElementById('logoutBtn');

            if (isAuthenticated) {
                authStatus.textContent = 'Authenticated';
                authStatus.className = 'success';
                tokenInfo.textContent = `Token: ${currentToken.substring(0, 50)}...`;
                tokenInfo.classList.remove('hidden');
                logoutBtn.classList.remove('hidden');
            } else {
                authStatus.textContent = 'Not authenticated';
                authStatus.className = 'info';
                tokenInfo.classList.add('hidden');
                logoutBtn.classList.add('hidden');
            }
        }

        function showAuthenticatedSections(loginData) {
            // 检查用户是否已启用双因素认证
            const isTwoFactorEnabled = loginData && loginData.twoFactorEnabled;

            if (!isTwoFactorEnabled) {
                // 显示启用双因素认证的部分
                document.getElementById('enableTwoFactorSection').classList.remove('hidden');
                checkPasskeyStatus();
            } else {
                // 隐藏启用双因素认证的部分
                document.getElementById('enableTwoFactorSection').classList.add('hidden');
            }

            // 显示其他认证后的部分
            document.getElementById('passkeySection').classList.remove('hidden');
            document.getElementById('signSection').classList.remove('hidden');
        }

        function hideAuthenticatedSections() {
            document.getElementById('enableTwoFactorSection').classList.add('hidden');
            document.getElementById('passkeySection').classList.add('hidden');
            document.getElementById('signSection').classList.add('hidden');
            hideTwoFactorSection();
        }

        function showResult(elementId, message, isSuccess = true) {
            const element = document.getElementById(elementId);
            element.textContent = message;
            element.className = `result ${isSuccess ? 'success' : 'error'}`;
            element.classList.remove('hidden');
        }

        async function registerUser() {
            const username = document.getElementById('registerUsername').value;
            const password = document.getElementById('registerPassword').value;
            const confirmPassword = document.getElementById('registerConfirmPassword').value;

            if (!username || !password || !confirmPassword) {
                showResult('registerResult', 'Please enter username, password and confirm password', false);
                return;
            }

            if (password !== confirmPassword) {
                showResult('registerResult', 'Passwords do not match', false);
                return;
            }

            try {
                const response = await fetch(`${baseUrl}/api/auth/register`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ userName: username, password: password, confirmPassword: confirmPassword })
                });

                const result = await response.json();
                if (response.ok) {
                    showResult('registerResult', 'User registered successfully!');
                } else {
                    showResult('registerResult', result.message || 'Registration failed', false);
                }
            } catch (error) {
                showResult('registerResult', 'Error: ' + error.message, false);
            }
        }

        async function loginUser() {
            const username = document.getElementById('loginUsername').value;
            const password = document.getElementById('loginPassword').value;

            if (!username || !password) {
                showResult('loginResult', 'Please enter username and password', false);
                return;
            }

            try {
                const response = await fetch(`${baseUrl}/api/auth/login`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ userName: username, password: password })
                });

                const result = await response.json();
                if (response.ok && result.success) {
                    if (result.data.requiresTwoFactor) {
                        // 需要双因素认证
                        showTwoFactorSection(result.data);
                        showResult('loginResult', 'Password verified. Please complete two-factor authentication.', true);
                    } else {
                        // 直接登录成功
                        currentToken = result.data.token;
                        localStorage.setItem('jwt_token', currentToken);
                        updateAuthStatus(true);
                        showAuthenticatedSections(result.data);
                        showResult('loginResult', 'Login successful!');
                    }
                } else {
                    showResult('loginResult', result.message || 'Login failed', false);
                }
            } catch (error) {
                showResult('loginResult', 'Error: ' + error.message, false);
            }
        }

        async function logout() {
            if (!currentToken) return;

            try {
                const response = await fetch(`${baseUrl}/api/auth/logout`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${currentToken}`
                    }
                });

                localStorage.removeItem('jwt_token');
                currentToken = null;
                updateAuthStatus(false);
                hideAuthenticatedSections();
                showResult('loginResult', 'Logged out successfully!');
            } catch (error) {
                console.error('Logout error:', error);
            }
        }

        async function registerPasskey() {
            if (!currentToken) {
                showResult('passkeyRegisterResult', 'Please login first', false);
                return;
            }

            try {
                const response = await fetch(`${baseUrl}/api/passkey/register-options`, {
                    method: 'GET',
                    headers: { 'Authorization': `Bearer ${currentToken}` }
                });

                if (!response.ok) {
                    if (response.status === 401) {
                        showResult('passkeyRegisterResult', 'Token expired, please login again', false);
                        logout();
                        return;
                    }
                    throw new Error('Failed to get registration options');
                }

                const options = await response.json();
                if (!options.success) {
                    showResult('passkeyRegisterResult', options.message || 'Failed to get options', false);
                    return;
                }

                const publicKeyOptions = {
                    ...options.data.options,
                    challenge: base64urlToUint8Array(options.data.options.challenge),
                    user: {
                        ...options.data.options.user,
                        id: base64urlToUint8Array(options.data.options.user.id)
                    }
                };

                if (options.data.options.excludeCredentials) {
                    publicKeyOptions.excludeCredentials = options.data.options.excludeCredentials.map(cred => ({
                        ...cred,
                        id: base64urlToUint8Array(cred.id)
                    }));
                }

                // Enable PRF extension
                publicKeyOptions.extensions = {
                    prf: {
                        eval: {
                            first: new Uint8Array(32)
                        }
                    }
                };

                const credential = await navigator.credentials.create({ publicKey: publicKeyOptions });

                const credentialId = arrayBufferToBase64(credential.rawId);

                // Extract PRF key for encryption
                const extensionResults = credential.getClientExtensionResults();
                if (!(extensionResults.prf && extensionResults.prf.results && extensionResults.prf.results.first)) {
                    throw new Error('PRF extension not supported or no results');
                }

                const prfKey = extensionResults.prf.results.first;
                extensionResults.prf.results.first = null; // Clear immediately

                // Generate ECDSA key pair
                showResult('passkeyRegisterResult', 'Generating ECDSA key pair...', true);
                const keyPair = await crypto.subtle.generateKey(
                    {
                        name: 'ECDSA',
                        namedCurve: 'P-256'
                    },
                    true, // extractable
                    ['sign', 'verify']
                );

                // Export public key
                const publicKey = await crypto.subtle.exportKey('spki', keyPair.publicKey);
                const publicKeyBase64 = arrayBufferToBase64(publicKey);

                // Export and encrypt private key
                const privateKey = await crypto.subtle.exportKey('pkcs8', keyPair.privateKey);
                const prfIv = crypto.getRandomValues(new Uint8Array(16));
                const prfCryptoKey = await crypto.subtle.importKey('raw', prfKey, { name: 'AES-GCM' }, false, ['encrypt']);
                const encryptedPrivateKey = await crypto.subtle.encrypt({ name: 'AES-GCM', iv: prfIv }, prfCryptoKey, privateKey);

                // Store encrypted private key with integrity protection
                const dataToStore = {
                    encryptedKey: arrayBufferToBase64(encryptedPrivateKey),
                    iv: arrayBufferToBase64(prfIv),
                    publicKey: publicKeyBase64,
                    version: 1,
                    timestamp: Date.now()
                };

                // Add HMAC for integrity protection
                const encoder = new TextEncoder();
                const dataString = JSON.stringify(dataToStore);
                const dataBytes = encoder.encode(dataString);

                const hmacKey = await crypto.subtle.importKey('raw', prfKey, { name: 'HMAC', hash: 'SHA-256' }, false, ['sign']);
                const integrityTag = await crypto.subtle.sign('HMAC', hmacKey, dataBytes);
                dataToStore.integrityTag = arrayBufferToBase64(integrityTag);

                localStorage.setItem(`encryptedPrivateKey_${credentialId}`, JSON.stringify(dataToStore));

                const registerResponse = await fetch(`${baseUrl}/api/passkey/register`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${currentToken}`
                    },
                    body: JSON.stringify({
                        flowId: options.data.flowId,
                        attestation: credential,
                        publicKey: publicKeyBase64
                    })
                });

                const registerResult = await registerResponse.json();
                if (registerResponse.ok && registerResult.success) {
                    showResult('passkeyRegisterResult', 'Passkey registered successfully!');
                    // 重新检查通行密钥状态，更新启用2FA的UI
                    checkPasskeyStatus();
                } else {
                    showResult('passkeyRegisterResult', registerResult.message || 'Registration failed', false);
                }
            } catch (error) {
                showResult('passkeyRegisterResult', 'Error: ' + error.message, false);
            }
        }

        async function signData() {
            if (!currentToken) {
                showResult('signResult', 'Please login first', false);
                return;
            }

            const dataToSign = document.getElementById('dataToSign').value;
            if (!dataToSign.trim()) {
                showResult('signResult', 'Please enter data to sign', false);
                return;
            }

            try {
                showResult('signResult', 'Authenticating and loading private key...', true);

                // Get verify options
                const optionsResponse = await fetch(`${baseUrl}/api/business/verify-options`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${currentToken}`,
                    }
                });

                if (!optionsResponse.ok) {
                    if (optionsResponse.status === 401) {
                        showResult('signResult', 'Token expired, please login again', false);
                        logout();
                        return;
                    }
                    throw new Error('Failed to get verify options');
                }

                const options = await optionsResponse.json();

                const publicKeyOptions = {
                    ...options,
                    challenge: base64urlToUint8Array(options.challenge)
                };

                if (options.allowCredentials) {
                    publicKeyOptions.allowCredentials = options.allowCredentials.map(cred => ({
                        ...cred,
                        id: base64urlToUint8Array(cred.id)
                    }));
                }

                // Enable PRF extension
                publicKeyOptions.extensions = {
                    prf: {
                        eval: {
                            first: new Uint8Array(32)
                        }
                    }
                };

                const credential = await navigator.credentials.get({ publicKey: publicKeyOptions });

                // Extract PRF key
                const extensionResults = credential.getClientExtensionResults();
                if (!(extensionResults.prf && extensionResults.prf.results && extensionResults.prf.results.first)) {
                    throw new Error('PRF extension not supported or no results');
                }

                const currentPrfKey = extensionResults.prf.results.first;
                extensionResults.prf.results.first = null;

                // Get credential ID for private key lookup
                const credentialId = arrayBufferToBase64(credential.rawId);

                // Decrypt private key using current PRF key
                const stored = localStorage.getItem(`encryptedPrivateKey_${credentialId}`);
                if (!stored) {
                    throw new Error('No stored private key found for this credential ID: ' + credentialId);
                }

                const storedData = JSON.parse(stored);

                // Verify data integrity
                const { integrityTag, ...dataWithoutTag } = storedData;
                const dataString = JSON.stringify(dataWithoutTag);
                const encoder = new TextEncoder();
                const dataBytes = encoder.encode(dataString);

                const hmacKey = await crypto.subtle.importKey('raw', currentPrfKey, { name: 'HMAC', hash: 'SHA-256' }, false, ['verify']);
                const isValidIntegrity = await crypto.subtle.verify('HMAC', hmacKey, base64ToArrayBuffer(integrityTag), dataBytes);

                if (!isValidIntegrity) {
                    throw new Error('Stored data integrity check failed');
                }

                const { encryptedKey, iv: prfIvBase64 } = storedData;
                const encryptedPrivateKey = base64ToArrayBuffer(encryptedKey);
                const prfIv = base64ToArrayBuffer(prfIvBase64);

                const prfCryptoKey = await crypto.subtle.importKey('raw', currentPrfKey, { name: 'AES-GCM' }, false, ['decrypt']);
                const privateKeyData = await crypto.subtle.decrypt({ name: 'AES-GCM', iv: prfIv }, prfCryptoKey, encryptedPrivateKey);

                // Import private key temporarily
                const tempPrivateKey = await crypto.subtle.importKey('pkcs8', privateKeyData, { name: 'ECDSA', namedCurve: 'P-256' }, false, ['sign']);

                showResult('signResult', 'Signing data...', true);

                const signature = await crypto.subtle.sign(
                    { name: 'ECDSA', hash: 'SHA-256' },
                    tempPrivateKey,
                    encoder.encode(dataToSign)
                );

                const signatureBase64 = arrayBufferToBase64(signature);

                // Verify with server
                const verifyResponse = await fetch(`${baseUrl}/api/business/verify`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${currentToken}`
                    },
                    body: JSON.stringify({
                        assertion: credential,
                        originalOptions: options,
                        data: dataToSign,
                        signature: signatureBase64
                    })
                });

                if (!verifyResponse.ok) {
                    const errorText = await verifyResponse.text();
                    throw new Error('Verification failed: ' + errorText);
                }

                showResult('signResult', `Data signed and verified successfully!\nSignature: ${signatureBase64}`, true);

            } catch (error) {
                showResult('signResult', 'Signing failed: ' + error.message, false);
                console.error('Sign error:', error);
            }
        }

        // Utility functions
        function arrayBufferToBase64(buffer) {
            const bytes = new Uint8Array(buffer);
            let binary = '';
            for (let i = 0; i < bytes.byteLength; i++) {
                binary += String.fromCharCode(bytes[i]);
            }
            return btoa(binary);
        }

        function base64ToArrayBuffer(base64) {
            const binaryString = atob(base64);
            const bytes = new Uint8Array(binaryString.length);
            for (let i = 0; i < binaryString.length; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }
            return bytes.buffer;
        }

        function base64urlToUint8Array(base64url) {
            const base64 = base64url.replace(/-/g, '+').replace(/_/g, '/');
            const rawData = window.atob(base64);
            const outputArray = new Uint8Array(rawData.length);
            for (let i = 0; i < rawData.length; ++i) {
                outputArray[i] = rawData.charCodeAt(i);
            }
            return outputArray;
        }

        // 双因素认证相关变量
        let currentTwoFactorData = null;

        function showTwoFactorSection(loginData) {
            currentTwoFactorData = loginData;

            // 隐藏登录表单
            document.getElementById('loginSection').classList.add('hidden');

            // 显示双因素认证表单
            document.getElementById('twoFactorSection').classList.remove('hidden');

            // 根据认证类型和可用选项显示相应的界面
            const twoFactorType = loginData.twoFactorType;
            const hasPasskeyOptions = loginData.passkeyOptions != null;

            // 检查是否有可用的2FA方法
            const hasPasskey = (twoFactorType & 8) && hasPasskeyOptions; // Passkey = 8
            const hasTotp = twoFactorType & 1; // AuthenticatorApp = 1
            const hasEmail = twoFactorType & 2; // Email = 2
            const hasSms = twoFactorType & 4; // Sms = 4

            if (hasPasskey) {
                // 有通行密钥选项，显示通行密钥界面
                document.getElementById('twoFactorPasskey').classList.remove('hidden');
                document.getElementById('twoFactorCode').classList.add('hidden');
            } else if (hasTotp || hasEmail || hasSms) {
                // 有其他2FA方法，显示代码输入界面
                document.getElementById('twoFactorPasskey').classList.add('hidden');
                document.getElementById('twoFactorCode').classList.remove('hidden');

                // 如果启用了通行密钥但没有绑定，显示提示
                if (twoFactorType & 8) {
                    showResult('twoFactorResult', '您已启用通行密钥双因素认证，但尚未绑定任何通行密钥。请使用其他验证方式，或先注册通行密钥。', true);
                }
            } else {
                // 没有可用的2FA方法
                showResult('twoFactorResult', '没有可用的双因素认证方法，请联系管理员。', false);
            }
        }

        function hideTwoFactorSection() {
            document.getElementById('twoFactorSection').classList.add('hidden');
            document.getElementById('loginSection').classList.remove('hidden');
            currentTwoFactorData = null;
        }

        async function verifyTwoFactorWithPasskey() {
            if (!currentTwoFactorData || !currentTwoFactorData.passkeyOptions) {
                showResult('twoFactorResult', 'Passkey options not available', false);
                return;
            }

            try {
                // Extract the options but exclude extensions to avoid conflicts
                const { extensions: _, ...serverOptions } = currentTwoFactorData.passkeyOptions;
                
                const publicKeyOptions = {
                    ...serverOptions,
                    challenge: base64urlToUint8Array(currentTwoFactorData.passkeyOptions.challenge)
                };

                if (currentTwoFactorData.passkeyOptions.allowCredentials) {
                    publicKeyOptions.allowCredentials = currentTwoFactorData.passkeyOptions.allowCredentials.map(cred => ({
                        ...cred,
                        id: base64urlToUint8Array(cred.id)
                    }));
                }

                // Enable PRF extension for private key encryption
                publicKeyOptions.extensions = {
                    prf: {
                        eval: {
                            first: new Uint8Array(32)
                        }
                    }
                };

                const credential = await navigator.credentials.get({ publicKey: publicKeyOptions });

                // Extract PRF key for encryption
                const extensionResults = credential.getClientExtensionResults();
                if (extensionResults.prf && extensionResults.prf.results && extensionResults.prf.results.first) {
                    prfKey = extensionResults.prf.results.first;
                    extensionResults.prf.results.first = null; // Clear immediately
                } else {
                    // Fallback: generate a random key for demo purposes
                    prfKey = crypto.getRandomValues(new Uint8Array(32));
                }

                // Check if private key is stored for this credential
                const credentialId = arrayBufferToBase64(credential.rawId);
                const stored = localStorage.getItem(`encryptedPrivateKey_${credentialId}`);
                let publicKeyBase64 = null;

                if (!stored) {
                    // No stored private key, generate new key pair
                    showResult('twoFactorResult', 'Generating private key pair for signing...', true);

                    const newKeyPair = await crypto.subtle.generateKey(
                        {
                            name: 'ECDSA',
                            namedCurve: 'P-256'
                        },
                        true, // extractable
                        ['sign', 'verify']
                    );

                    // Export public key
                    const publicKey = await crypto.subtle.exportKey('spki', newKeyPair.publicKey);
                    publicKeyBase64 = arrayBufferToBase64(publicKey);

                    // Export and encrypt private key
                    const privateKey = await crypto.subtle.exportKey('pkcs8', newKeyPair.privateKey);
                    const prfIv = crypto.getRandomValues(new Uint8Array(16));
                    const prfCryptoKey = await crypto.subtle.importKey('raw', prfKey, { name: 'AES-GCM' }, false, ['encrypt']);
                    const encryptedPrivateKey = await crypto.subtle.encrypt({ name: 'AES-GCM', iv: prfIv }, prfCryptoKey, privateKey);

                    // Store encrypted private key with integrity protection
                    const dataToStore = {
                        encryptedKey: arrayBufferToBase64(encryptedPrivateKey),
                        iv: arrayBufferToBase64(prfIv),
                        publicKey: publicKeyBase64,
                        version: 1,
                        timestamp: Date.now()
                    };

                    // Add HMAC for integrity protection
                    const encoder = new TextEncoder();
                    const dataString = JSON.stringify(dataToStore);
                    const dataBytes = encoder.encode(dataString);

                    const hmacKey = await crypto.subtle.importKey('raw', prfKey, { name: 'HMAC', hash: 'SHA-256' }, false, ['sign']);
                    const integrityTag = await crypto.subtle.sign('HMAC', hmacKey, dataBytes);
                    dataToStore.integrityTag = arrayBufferToBase64(integrityTag);

                    localStorage.setItem(`encryptedPrivateKey_${credentialId}`, JSON.stringify(dataToStore));
                } else {
                    // Get public key from stored data
                    const storedData = JSON.parse(stored);
                    publicKeyBase64 = storedData.publicKey;
                }

                const verifyResponse = await fetch(`${baseUrl}/api/two-factor/verify`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        twoFactorId: currentTwoFactorData.twoFactorId,
                        codes: {
                            "Passkey": JSON.stringify(credential)
                        },
                        publicKey: publicKeyBase64
                    })
                });

                const verifyResult = await verifyResponse.json();
                if (verifyResponse.ok && verifyResult.success) {
                    currentToken = verifyResult.data.token;
                    localStorage.setItem('jwt_token', currentToken);
                    updateAuthStatus(true);
                    showAuthenticatedSections(verifyResult.data);
                    hideTwoFactorSection();
                    showResult('twoFactorResult', 'Two-factor authentication successful!', true);
                } else {
                    showResult('twoFactorResult', verifyResult.message || 'Verification failed', false);
                }
            } catch (error) {
                showResult('twoFactorResult', 'Error: ' + error.message, false);
            }
        }

        async function verifyTwoFactorWithCode() {
            const code = document.getElementById('twoFactorCodeInput').value;
            if (!code) {
                showResult('twoFactorResult', 'Please enter verification code', false);
                return;
            }

            try {
                const verifyResponse = await fetch(`${baseUrl}/api/two-factor/verify`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        twoFactorId: currentTwoFactorData.twoFactorId,
                        codes: { "TOTP": code } // 假设是TOTP验证码
                    })
                });

                const verifyResult = await verifyResponse.json();
                if (verifyResponse.ok && verifyResult.success) {
                    currentToken = verifyResult.data.token;
                    localStorage.setItem('jwt_token', currentToken);
                    updateAuthStatus(true);
                    showAuthenticatedSections(verifyResult.data);
                    hideTwoFactorSection();
                    showResult('twoFactorResult', 'Two-factor authentication successful!', true);
                } else {
                    showResult('twoFactorResult', verifyResult.message || 'Verification failed', false);
                }
            } catch (error) {
                showResult('twoFactorResult', 'Error: ' + error.message, false);
            }
        }

        function cancelTwoFactor() {
            hideTwoFactorSection();
            showResult('loginResult', 'Two-factor authentication cancelled', false);
        }

        async function checkPasskeyStatus() {
            try {
                // 尝试获取通行密钥登录选项，如果成功说明已绑定通行密钥
                const response = await fetch(`${baseUrl}/api/passkey/login-options`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${currentToken}`
                    }
                });

                if (response.ok) {
                    const result = await response.json();
                    if (result.success) {
                        // 已绑定通行密钥
                        document.getElementById('passkeyRequiredStep').classList.add('hidden');
                        document.getElementById('enableTwoFactorReady').classList.remove('hidden');
                    } else {
                        // 未绑定通行密钥
                        document.getElementById('passkeyRequiredStep').classList.remove('hidden');
                        document.getElementById('enableTwoFactorReady').classList.add('hidden');
                    }
                } else {
                    // API调用失败
                    document.getElementById('passkeyRequiredStep').classList.remove('hidden');
                    document.getElementById('enableTwoFactorReady').classList.add('hidden');
                }
            } catch (error) {
                // 出错时显示需要绑定通行密钥
                document.getElementById('passkeyRequiredStep').classList.remove('hidden');
                document.getElementById('enableTwoFactorReady').classList.add('hidden');
            }
        }

        async function enableTwoFactor() {
            try {
                const response = await fetch(`${baseUrl}/api/two-factor/enable`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${currentToken}`,
                    }
                });

                const result = await response.json();
                if (response.ok && result.success) {
                    showResult('enableTwoFactorResult', 'Two-factor authentication enabled successfully!', true);
                    // 隐藏启用2FA部分
                    document.getElementById('enableTwoFactorSection').classList.add('hidden');
                } else {
                    showResult('enableTwoFactorResult', result.message || 'Failed to enable two-factor authentication', false);
                }
            } catch (error) {
                showResult('enableTwoFactorResult', 'Error: ' + error.message, false);
            }
        }
    </script>
</body>

</html>