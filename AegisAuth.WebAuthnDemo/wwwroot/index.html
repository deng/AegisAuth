<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebAuthn Business Signing Demo</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
        }

        .section {
            margin-bottom: 30px;
            border: 1px solid #ccc;
            padding: 20px;
        }

        button {
            padding: 10px 20px;
            margin: 5px;
        }

        input,
        textarea {
            display: block;
            margin: 10px 0;
            width: 100%;
        }

        .result {
            margin-top: 10px;
            padding: 10px;
            background: #f0f0f0;
        }

        .success {
            background: #d4edda;
            color: #155724;
        }

        .error {
            background: #f8d7da;
            color: #721c24;
        }
    </style>
</head>

<body>
    <h1>WebAuthn Demo with PRF-based Key Storage</h1>

    <div style="background: #e7f3ff; padding: 15px; margin: 20px 0; border-radius: 5px;">
        <h3>Usage Guide:</h3>
        <ol>
            <li><strong>Register</strong> a passkey (automatically generates and securely stores an encrypted ECDSA private key)</li>
            <li><strong>Login</strong> with passkey (generates a new key pair and stores it if no private key exists for this credential)</li>
            <li><strong>Sign</strong> data using the stored private key (requires fresh WebAuthn authentication to access the encrypted key)</li>
        </ol>
    </div>

    <div class="section">
        <h2>1. Register Passkey</h2>
        <button onclick="registerPasskey()">Register Passkey</button>
        <div id="registerResult" class="result"></div>
    </div>

    <div class="section">
        <h2>2. Login with Passkey</h2>
        <button onclick="loginPasskey()">Login</button>
        <div id="loginResult" class="result"></div>
    </div>

    <div class="section">
        <h2>3. Sign Data with Stored Private Key</h2>
        <p style="color: #666; font-size: 14px;">Note: Signing requires fresh WebAuthn authentication to securely access the stored private key.</p>

        <div id="useKeySection" style="display: block; margin-top: 20px;">
            <label>Data to Sign:</label>
            <textarea id="dataToSign" rows="3"
                placeholder="Enter data to sign">This is data to be signed with the stored private key.</textarea>

            <button onclick="signData()">Sign Data</button>
            <div id="signResult" class="result"></div>
        </div>
    </div>

    <script>
        const baseUrl = 'http://localhost:5202'; // Updated to match current server port
        let prfKey = null; // Store the PRF-derived key for encryption

        function showResult(elementId, message, isSuccess = true) {
            const element = document.getElementById(elementId);
            element.textContent = message;
            element.className = `result ${isSuccess ? 'success' : 'error'}`;
            if (isSuccess) {
                console.log(message);
            } else {
                console.error(message);
            }
        }

        async function registerPasskey() {
            try {
                const response = await fetch(`${baseUrl}/api/webauthn/register-options`, { method: 'POST' });
                if (!response.ok) throw new Error('Failed to get registration options');

                const options = await response.json();

                // Convert challenge from base64url to Uint8Array
                const publicKeyOptions = {
                    ...options,
                    challenge: base64urlToUint8Array(options.challenge),
                    user: {
                        ...options.user,
                        id: base64urlToUint8Array(options.user.id)
                    }
                };

                // Convert excludeCredentials if present
                if (options.excludeCredentials) {
                    publicKeyOptions.excludeCredentials = options.excludeCredentials.map(cred => ({
                        ...cred,
                        id: base64urlToUint8Array(cred.id)
                    }));
                }

                // Enable PRF extension for key derivation with a fixed salt for consistency
                publicKeyOptions.extensions = {
                    prf: {
                        eval: {
                            first: new Uint8Array(32) // Use a fixed salt for consistent key derivation
                        }
                    }
                };

                const credential = await navigator.credentials.create({ publicKey: publicKeyOptions });

                const credentialId = arrayBufferToBase64(credential.rawId);

                // Extract PRF key for encryption
                const extensionResults = credential.getClientExtensionResults();
                if (!(extensionResults.prf && extensionResults.prf.results && extensionResults.prf.results.first)) {
                    throw new Error('PRF extension not supported or no results');
                }

                const prfKey = extensionResults.prf.results.first;
                extensionResults.prf.results.first = null; // Clear immediately

                // Generate ECDSA key pair
                showResult('registerResult', 'Generating ECDSA key pair...', true);
                const keyPair = await crypto.subtle.generateKey(
                    {
                        name: 'ECDSA',
                        namedCurve: 'P-256'
                    },
                    true, // extractable
                    ['sign', 'verify']
                );

                // Export public key
                const publicKey = await crypto.subtle.exportKey('spki', keyPair.publicKey);
                const publicKeyBase64 = arrayBufferToBase64(publicKey);

                // Export and encrypt private key
                const privateKey = await crypto.subtle.exportKey('pkcs8', keyPair.privateKey);
                const prfIv = crypto.getRandomValues(new Uint8Array(16));
                const prfCryptoKey = await crypto.subtle.importKey('raw', prfKey, { name: 'AES-GCM' }, false, ['encrypt']);
                const encryptedPrivateKey = await crypto.subtle.encrypt({ name: 'AES-GCM', iv: prfIv }, prfCryptoKey, privateKey);

                // Store encrypted private key with integrity protection
                const dataToStore = {
                    encryptedKey: arrayBufferToBase64(encryptedPrivateKey),
                    iv: arrayBufferToBase64(prfIv),
                    publicKey: publicKeyBase64,
                    version: 1,
                    timestamp: Date.now()
                };

                // Add HMAC for integrity protection
                const encoder = new TextEncoder();
                const dataString = JSON.stringify(dataToStore);
                const dataBytes = encoder.encode(dataString);

                const hmacKey = await crypto.subtle.importKey('raw', prfKey, { name: 'HMAC', hash: 'SHA-256' }, false, ['sign']);
                const integrityTag = await crypto.subtle.sign('HMAC', hmacKey, dataBytes);
                dataToStore.integrityTag = arrayBufferToBase64(integrityTag);

                localStorage.setItem(`encryptedPrivateKey_${credentialId}`, JSON.stringify(dataToStore));

                const registerResponse = await fetch(`${baseUrl}/api/webauthn/register`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        attestation: credential,
                        originalOptions: options,
                        publicKey: publicKeyBase64
                    })
                });

                if (registerResponse.ok) {
                    showResult('registerResult', 'Registration successful! Private key generated and stored securely.');
                } else {
                    throw new Error('Registration failed');
                }
            } catch (error) {
                showResult('registerResult', 'Error: ' + error.message, false);
            }
        }

        async function loginPasskey() {
            try {
                const response = await fetch(`${baseUrl}/api/webauthn/login-options`, { method: 'POST' });
                if (!response.ok) throw new Error('Failed to get login options');

                const options = await response.json();

                // Convert challenge from base64url to Uint8Array
                const publicKeyOptions = {
                    ...options,
                    challenge: base64urlToUint8Array(options.challenge)
                };

                // Convert allowCredentials if present
                if (options.allowCredentials) {
                    publicKeyOptions.allowCredentials = options.allowCredentials.map(cred => ({
                        ...cred,
                        id: base64urlToUint8Array(cred.id)
                    }));
                }

                // Enable PRF extension for key derivation with a fixed salt for consistency
                publicKeyOptions.extensions = {
                    prf: {
                        eval: {
                            first: new Uint8Array(32) // Use a fixed salt for consistent key derivation
                        }
                    }
                };

                const credential = await navigator.credentials.get({ publicKey: publicKeyOptions });

                // Extract PRF key for encryption
                const extensionResults = credential.getClientExtensionResults();
                console.log('Extension results available:', !!(extensionResults.prf && extensionResults.prf.results && extensionResults.prf.results.first));
                if (extensionResults.prf && extensionResults.prf.results && extensionResults.prf.results.first) {
                    prfKey = extensionResults.prf.results.first; // Uint8Array - this should be consistent for the same credential
                    console.log('PRF key obtained successfully, length:', prfKey.length);

                    // Clear extension results immediately to reduce memory exposure
                    extensionResults.prf.results.first = null;

                    // SECURITY: Never log the actual PRF key value in production
                    // console.log('PRF key (hex):', Array.from(prfKey).map(b => b.toString(16).padStart(2, '0')).join(''));
                } else {
                    // Fallback: generate a random key for demo purposes
                    prfKey = crypto.getRandomValues(new Uint8Array(32));
                    console.warn('PRF extension not supported or no results, using random key for demo');
                    // SECURITY: Never log the actual key value in production
                    // console.log('Random PRF key (hex):', Array.from(prfKey).map(b => b.toString(16).padStart(2, '0')).join(''));
                }

                // Check if private key is stored for this credential
                const credentialId = arrayBufferToBase64(credential.rawId);
                const stored = localStorage.getItem(`encryptedPrivateKey_${credentialId}`);
                let publicKeyBase64 = null;

                if (!stored) {
                    // No stored private key, generate new key pair
                    showResult('loginResult', 'No stored private key found, generating new key pair...', true);

                    const newKeyPair = await crypto.subtle.generateKey(
                        {
                            name: 'ECDSA',
                            namedCurve: 'P-256'
                        },
                        true, // extractable
                        ['sign', 'verify']
                    );

                    // Export public key
                    const publicKey = await crypto.subtle.exportKey('spki', newKeyPair.publicKey);
                    publicKeyBase64 = arrayBufferToBase64(publicKey);

                    // Export and encrypt private key
                    const privateKey = await crypto.subtle.exportKey('pkcs8', newKeyPair.privateKey);
                    const prfIv = crypto.getRandomValues(new Uint8Array(16));
                    const prfCryptoKey = await crypto.subtle.importKey('raw', prfKey, { name: 'AES-GCM' }, false, ['encrypt']);
                    const encryptedPrivateKey = await crypto.subtle.encrypt({ name: 'AES-GCM', iv: prfIv }, prfCryptoKey, privateKey);

                    // Store encrypted private key with integrity protection
                    const dataToStore = {
                        encryptedKey: arrayBufferToBase64(encryptedPrivateKey),
                        iv: arrayBufferToBase64(prfIv),
                        publicKey: publicKeyBase64,
                        version: 1,
                        timestamp: Date.now()
                    };

                    // Add HMAC for integrity protection
                    const encoder = new TextEncoder();
                    const dataString = JSON.stringify(dataToStore);
                    const dataBytes = encoder.encode(dataString);

                    const hmacKey = await crypto.subtle.importKey('raw', prfKey, { name: 'HMAC', hash: 'SHA-256' }, false, ['sign']);
                    const integrityTag = await crypto.subtle.sign('HMAC', hmacKey, dataBytes);
                    dataToStore.integrityTag = arrayBufferToBase64(integrityTag);

                    localStorage.setItem(`encryptedPrivateKey_${credentialId}`, JSON.stringify(dataToStore));

                    showResult('loginResult', 'New private key generated and stored!', true);
                }

                // Final login with server to complete authentication and store/update credential
                const requestBody = {
                    assertion: credential,
                    originalOptions: options
                };
                if (publicKeyBase64) {
                    requestBody.publicKey = publicKeyBase64;
                }
                const loginResponse = await fetch(`${baseUrl}/api/webauthn/login`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestBody)
                });

                if (!loginResponse.ok) {
                    throw new Error('Login failed');
                } else {
                    showResult('loginResult', 'Login successful!');
                }
            } catch (error) {
                showResult('loginResult', 'Error: ' + error.message, false);
            }
        }

        // Sign data with loaded private key
        async function signData() {
            try {
                const dataToSign = document.getElementById('dataToSign').value;
                if (!dataToSign.trim()) {
                    throw new Error('Please enter data to sign');
                }

                showResult('signResult', 'Authenticating and loading private key...', true);

                // Perform initial WebAuthn authentication to get PRF key
                const initialResponse = await fetch(`${baseUrl}/api/xbusiness/verify-options`, { method: 'POST' });
                if (!initialResponse.ok) throw new Error('Failed to get verify options');

                const options = await initialResponse.json();

                const publicKeyOptions = {
                    ...options,
                    challenge: base64urlToUint8Array(options.challenge)
                };

                if (options.allowCredentials) {
                    publicKeyOptions.allowCredentials = options.allowCredentials.map(cred => ({
                        ...cred,
                        id: base64urlToUint8Array(cred.id)
                    }));
                }

                // Enable PRF extension
                publicKeyOptions.extensions = {
                    prf: {
                        eval: {
                            first: new Uint8Array(32)
                        }
                    }
                };

                const credential = await navigator.credentials.get({ publicKey: publicKeyOptions });

                // Extract PRF key
                const extensionResults = credential.getClientExtensionResults();
                if (!(extensionResults.prf && extensionResults.prf.results && extensionResults.prf.results.first)) {
                    throw new Error('PRF extension not supported or no results');
                }

                const currentPrfKey = extensionResults.prf.results.first;
                extensionResults.prf.results.first = null; // Clear immediately

                // Get credential ID for private key lookup
                const credentialId = arrayBufferToBase64(credential.rawId);

                // Decrypt private key using current PRF key
                const stored = localStorage.getItem(`encryptedPrivateKey_${credentialId}`);
                if (!stored) {
                    throw new Error('No stored private key found for this credential ID: ' + credentialId);
                }

                const storedData = JSON.parse(stored);

                // Verify data integrity
                const { integrityTag, ...dataWithoutTag } = storedData;
                const dataString = JSON.stringify(dataWithoutTag);
                const encoder = new TextEncoder();
                const dataBytes = encoder.encode(dataString);

                const hmacKey = await crypto.subtle.importKey('raw', currentPrfKey, { name: 'HMAC', hash: 'SHA-256' }, false, ['verify']);
                const isValidIntegrity = await crypto.subtle.verify('HMAC', hmacKey, base64ToArrayBuffer(integrityTag), dataBytes);

                if (!isValidIntegrity) {
                    throw new Error('Stored data integrity check failed - data may have been tampered with');
                }

                const { encryptedKey, iv: prfIvBase64 } = storedData;
                const encryptedPrivateKey = base64ToArrayBuffer(encryptedKey);
                const prfIv = base64ToArrayBuffer(prfIvBase64);

                const prfCryptoKey = await crypto.subtle.importKey('raw', currentPrfKey, { name: 'AES-GCM' }, false, ['decrypt']);
                const privateKeyData = await crypto.subtle.decrypt({ name: 'AES-GCM', iv: prfIv }, prfCryptoKey, encryptedPrivateKey);

                // Import private key temporarily
                const tempPrivateKey = await crypto.subtle.importKey('pkcs8', privateKeyData, { name: 'ECDSA', namedCurve: 'P-256' }, false, ['sign']);

                showResult('signResult', 'Signing data...', true);

                const signature = await crypto.subtle.sign(
                    { name: 'ECDSA', hash: 'SHA-256' },
                    tempPrivateKey,
                    encoder.encode(dataToSign)
                );

                const signatureBase64 = arrayBufferToBase64(signature);

                // Verify with server (combines WebAuthn verification and signature verification)
                const verifyResponse = await fetch(`${baseUrl}/api/xbusiness/verify`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        assertion: credential,
                        originalOptions: options,
                        data: dataToSign,
                        signature: signatureBase64
                    })
                });

                if (!verifyResponse.ok) {
                    const errorText = await verifyResponse.text();
                    throw new Error('Verification failed: ' + errorText);
                }

                showResult('signResult', `Data signed and verified successfully!\nSignature: ${signatureBase64}`, true);

            } catch (error) {
                showResult('signResult', 'Signing failed: ' + error.message, false);
                console.error('Sign error:', error);
            }
        }

        // Utility functions for base64 and ArrayBuffer conversion
        function arrayBufferToBase64(buffer) {
            const bytes = new Uint8Array(buffer);
            let binary = '';
            for (let i = 0; i < bytes.byteLength; i++) {
                binary += String.fromCharCode(bytes[i]);
            }
            return btoa(binary);
        }

        // Utility function to convert base64 to ArrayBuffer
        function base64ToArrayBuffer(base64) {
            const binaryString = atob(base64);
            const bytes = new Uint8Array(binaryString.length);
            for (let i = 0; i < binaryString.length; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }
            return bytes.buffer;
        }

        // Utility function to convert base64url to Uint8Array
        function base64urlToUint8Array(base64url) {
            const base64 = base64url.replace(/-/g, '+').replace(/_/g, '/');
            const rawData = window.atob(base64);
            const outputArray = new Uint8Array(rawData.length);
            for (let i = 0; i < rawData.length; ++i) {
                outputArray[i] = rawData.charCodeAt(i);
            }
            return outputArray;
        }
    </script>
</body>

</html>